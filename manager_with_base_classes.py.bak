"""
Basketball Scoreboard Plugin for LEDMatrix

Displays live, recent, and upcoming basketball games across NBA, NCAA Men's,
NCAA Women's, and WNBA leagues. Shows real-time scores, game status, and team logos.

This plugin perfectly mirrors the functionality of the old basketball managers
while adapting to the plugin system architecture.

API Version: 1.0.0
"""

import logging
import time
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional

import pytz
import requests
from PIL import Image, ImageDraw, ImageFont

from src.plugin_system.base_plugin import BasePlugin
from src.base_classes.basketball import Basketball, BasketballLive
from src.base_classes.sports import SportsRecent, SportsUpcoming

logger = logging.getLogger(__name__)

# ESPN API URLs for each league
ESPN_NBA_SCOREBOARD_URL = "https://site.api.espn.com/apis/site/v2/sports/basketball/nba/scoreboard"
ESPN_WNBA_SCOREBOARD_URL = "https://site.api.espn.com/apis/site/v2/sports/basketball/wnba/scoreboard"
ESPN_NCAAMB_SCOREBOARD_URL = "https://site.api.espn.com/apis/site/v2/sports/basketball/mens-college-basketball/scoreboard"
ESPN_NCAAWB_SCOREBOARD_URL = "https://site.api.espn.com/apis/site/v2/sports/basketball/womens-college-basketball/scoreboard"


class BasketballPluginManager(BasePlugin, Basketball):
    """
    Basketball scoreboard plugin supporting NBA, WNBA, NCAA Men's, and NCAA Women's basketball.
    
    This plugin provides three display modes:
    - Live: Current games in progress
    - Recent: Recently completed games
    - Upcoming: Scheduled upcoming games
    
    Supports multiple leagues with independent configuration per league.
    """

    def __init__(
        self,
        plugin_id: str,
        config: Dict[str, Any],
        display_manager,
        cache_manager,
        plugin_manager
    ):
        """Initialize the basketball plugin with legacy manager compatibility."""
        # Initialize plugin base first - sets up logger and basic attributes
        BasePlugin.__init__(self, plugin_id, config, display_manager, cache_manager, plugin_manager)
        
        # Get the sport_key from config (first enabled league)
        sport_key = self._get_sport_key_from_config(config)
        
        # Initialize Basketball base class with required parameters
        # This will set up fonts, display dimensions, headers, etc.
        Basketball.__init__(
            self,
            config=config,
            display_manager=display_manager,
            cache_manager=cache_manager,
            logger=self.logger,
            sport_key=sport_key
        )
        
        # League configurations
        self.league_configs = {
            'nba': {
                'enabled': config.get('nba_enabled', True),
                'url': ESPN_NBA_SCOREBOARD_URL,
                'sport_key': 'nba',
                'league': 'nba',
                'logo_dir': 'assets/sports/nba_logos',
                'favorite_teams': config.get('nba_favorite_teams', []),
                'display_modes': {
                    'nba_live': config.get('nba_display_modes_live', True),
                    'nba_recent': config.get('nba_display_modes_recent', True),
                    'nba_upcoming': config.get('nba_display_modes_upcoming', True),
                },
                'recent_games_to_show': config.get('nba_recent_games_to_show', 5),
                'upcoming_games_to_show': config.get('nba_upcoming_games_to_show', 1),
            },
            'wnba': {
                'enabled': config.get('wnba_enabled', False),
                'url': ESPN_WNBA_SCOREBOARD_URL,
                'sport_key': 'wnba',
                'league': 'wnba',
                'logo_dir': 'assets/sports/wnba_logos',
                'favorite_teams': config.get('wnba_favorite_teams', []),
                'display_modes': {
                    'wnba_live': config.get('wnba_display_modes_live', True),
                    'wnba_recent': config.get('wnba_display_modes_recent', True),
                    'wnba_upcoming': config.get('wnba_display_modes_upcoming', True),
                },
                'recent_games_to_show': config.get('wnba_recent_games_to_show', 1),
                'upcoming_games_to_show': config.get('wnba_upcoming_games_to_show', 1),
            },
            'ncaam': {
                'enabled': config.get('ncaam_basketball_enabled', False),
                'url': ESPN_NCAAMB_SCOREBOARD_URL,
                'sport_key': 'ncaam_basketball',
                'league': 'mens-college-basketball',
                'logo_dir': 'assets/sports/ncaa_logos',
                'favorite_teams': config.get('ncaam_basketball_favorite_teams', []),
                'display_modes': {
                    'ncaam_basketball_live': config.get('ncaam_basketball_display_modes_live', True),
                    'ncaam_basketball_recent': config.get('ncaam_basketball_display_modes_recent', True),
                    'ncaam_basketball_upcoming': config.get('ncaam_basketball_display_modes_upcoming', True),
                },
                'recent_games_to_show': config.get('ncaam_basketball_recent_games_to_show', 1),
                'upcoming_games_to_show': config.get('ncaam_basketball_upcoming_games_to_show', 1),
            },
            'ncaaw': {
                'enabled': config.get('ncaaw_basketball_enabled', False),
                'url': ESPN_NCAAWB_SCOREBOARD_URL,
                'sport_key': 'ncaaw_basketball',
                'league': 'womens-college-basketball',
                'logo_dir': 'assets/sports/ncaa_logos',
                'favorite_teams': config.get('ncaaw_basketball_favorite_teams', []),
                'display_modes': {
                    'ncaaw_basketball_live': config.get('ncaaw_basketball_display_modes_live', True),
                    'ncaaw_basketball_recent': config.get('ncaaw_basketball_display_modes_recent', True),
                    'ncaaw_basketball_upcoming': config.get('ncaaw_basketball_display_modes_upcoming', True),
                },
                'recent_games_to_show': config.get('ncaaw_basketball_recent_games_to_show', 1),
                'upcoming_games_to_show': config.get('ncaaw_basketball_upcoming_games_to_show', 1),
            },
        }
        
        # Track current mode and games
        self.current_mode = None
        self.current_games = []
        
        # Log initialization
        enabled_leagues = [k for k, v in self.league_configs.items() if v['enabled']]
        logger.info(f"Basketball plugin initialized with leagues: {enabled_leagues}")
    
    def _get_sport_key_from_config(self, config: Dict[str, Any]) -> str:
        """Determine the primary sport key from config."""
        if config.get('nba_enabled', True):
            return 'nba'
        elif config.get('wnba_enabled', False):
            return 'wnba'
        elif config.get('ncaam_basketball_enabled', False):
            return 'ncaam_basketball'
        elif config.get('ncaaw_basketball_enabled', False):
            return 'ncaaw_basketball'
        return 'nba'  # Default
    
    def update(self) -> None:
        """Update game data for all enabled leagues."""
        try:
            all_games = []
            
            for league_key, league_config in self.league_configs.items():
                if not league_config['enabled']:
                    continue
                
                # Fetch games for this league
                games = self._fetch_league_games(league_key, league_config)
                for game in games:
                    game['league_key'] = league_key
                    game['league_config'] = league_config
                all_games.extend(games)
            
            self.current_games = all_games
            
            logger.debug(f"Updated basketball data: {len(all_games)} total games")
            
        except Exception as e:
            logger.error(f"Error updating basketball data: {e}", exc_info=True)
    
    def _fetch_league_games(self, league_key: str, league_config: Dict) -> List[Dict]:
        """Fetch games for a specific league using the Basketball base class methods."""
        try:
            # Use the Basketball base class's _fetch_nba_api_data equivalent
            # We need to adapt the sport_key dynamically
            original_sport_key = self.sport_key
            self.sport_key = league_config['sport_key']
            
            # Get the API URL for this league
            api_url = league_config['url']
            
            # Fetch data using base class method
            # We'll implement league-specific fetching
            data = self._fetch_api_data(api_url, league_config)
            
            games = []
            if data and 'events' in data:
                for event in data['events']:
                    game = self._extract_game_details(event)
                    if game:
                        # Set league-specific attributes
                        game['sport_key'] = league_config['sport_key']
                        game['league'] = league_config['league']
                        game['logo_dir'] = league_config['logo_dir']
                        games.append(game)
            
            # Restore original sport_key
            self.sport_key = original_sport_key
            
            return games
            
        except Exception as e:
            logger.error(f"Error fetching {league_key} games: {e}", exc_info=True)
            return []
    
    def _fetch_api_data(self, url: str, league_config: Dict) -> Optional[Dict]:
        """Fetch data from ESPN API with caching."""
        try:
            # Build cache key
            cache_key = f"basketball_{league_config['sport_key']}_{datetime.now().strftime('%Y%m%d')}"
            
            # Check cache
            cached = self.cache_manager.get(cache_key)
            if cached:
                return cached
            
            # Fetch from API
            response = requests.get(url, headers=self.headers, timeout=30)
            response.raise_for_status()
            
            data = response.json()
            
            # Cache the result
            self.cache_manager.set(cache_key, data, ttl=3600)
            
            return data
            
        except Exception as e:
            logger.error(f"Error fetching API data: {e}", exc_info=True)
            return None
    
    def display(self, force_clear: bool = False, display_mode: str = None) -> None:
        """
        Display basketball games based on the current mode.
        
        Args:
            force_clear: If True, clear display before rendering
            display_mode: Specific mode to display (optional)
        """
        try:
            # Determine which mode to display
            mode = display_mode or self._determine_display_mode()
            
            if not mode:
                logger.warning("No display mode available")
                return
            
            # Filter games for this mode
            filtered_games = self._filter_games_for_mode(mode)
            
            if not filtered_games:
                self._display_no_games_message(mode)
                return
            
            # Display the first game
            self.current_mode = mode
            self.current_game = filtered_games[0]
            
            # Use BasketballLive's display method for live games
            if 'live' in mode:
                self._display_live_game(self.current_game, force_clear)
            else:
                # Use base class display for recent/upcoming
                self._draw_scorebug_layout(self.current_game, force_clear)
            
        except Exception as e:
            logger.error(f"Error displaying basketball game: {e}", exc_info=True)
    
    def _determine_display_mode(self) -> Optional[str]:
        """Determine which display mode to use based on available games."""
        # Priority: live > recent > upcoming
        for game in self.current_games:
            if game.get('is_live'):
                for league_key, league_config in self.league_configs.items():
                    if league_config['enabled'] and f"{league_key}_live" in str(game):
                        return f"{league_config['sport_key']}_live"
        
        # Check for recent games
        for game in self.current_games:
            if game.get('is_final'):
                for league_key, league_config in self.league_configs.items():
                    if league_config['enabled'] and f"{league_key}_recent" in str(game):
                        return f"{league_config['sport_key']}_recent"
        
        # Check for upcoming games
        for game in self.current_games:
            if game.get('is_upcoming'):
                for league_key, league_config in self.league_configs.items():
                    if league_config['enabled'] and f"{league_key}_upcoming" in str(game):
                        return f"{league_config['sport_key']}_upcoming"
        
        return None
    
    def _filter_games_for_mode(self, mode: str) -> List[Dict]:
        """Filter games based on display mode."""
        filtered = []
        
        for game in self.current_games:
            league_config = game.get('league_config', {})
            display_modes = league_config.get('display_modes', {})
            
            # Check if this mode is enabled for this league
            if mode in display_modes and display_modes[mode]:
                # Filter by game state
                if 'live' in mode and game.get('is_live'):
                    filtered.append(game)
                elif 'recent' in mode and game.get('is_final'):
                    filtered.append(game)
                elif 'upcoming' in mode and game.get('is_upcoming'):
                    filtered.append(game)
        
        return filtered[:5]  # Limit to 5 games
    
    def _display_live_game(self, game: Dict, force_clear: bool) -> None:
        """Display a live game using the BasketballLive rendering."""
        # This will use the _draw_scorebug_layout from BasketballLive
        # which handles logos, scores, time, period, etc.
        self._draw_scorebug_layout(game, force_clear)
    
    def _display_no_games_message(self, mode: str) -> None:
        """Display a message when no games are available."""
        try:
            img = Image.new('RGB', (self.display_width, self.display_height), (0, 0, 0))
            draw = ImageDraw.Draw(img)
            
            mode_messages = {
                'live': 'No Live Games',
                'recent': 'No Recent Games',
                'upcoming': 'No Upcoming Games'
            }
            
            message = 'No Games'
            for key, msg in mode_messages.items():
                if key in mode:
                    message = msg
                    break
            
            draw.text((5, 12), message, fill=(150, 150, 150))
            
            self.display_manager.image = img.copy()
            self.display_manager.update_display()
            
        except Exception as e:
            logger.error(f"Error displaying no games message: {e}", exc_info=True)
    
    def get_display_duration(self) -> float:
        """Get the display duration for this plugin."""
        return self.config.get('display_duration', 15.0)
    
    def get_info(self) -> Dict[str, Any]:
        """Return plugin information."""
        info = {
            'plugin_id': self.plugin_id,
            'enabled': self.enabled,
            'total_games': len(self.current_games),
            'current_mode': self.current_mode,
            'leagues': {
                k: {'enabled': v['enabled']} 
                for k, v in self.league_configs.items()
            }
        }
        return info
    
    def cleanup(self) -> None:
        """Cleanup resources."""
        self.current_games = []
        logger.info("Basketball plugin cleaned up")
